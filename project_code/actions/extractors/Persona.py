import numpy as np
import pandas as pd
import re
from typing import Union, List

from actions.generators import GenderInferrer, InferCondition


class PersonaExtractor:
    def __init__(self, dataframes: List[pd.DataFrame], destination_dir: str = "../data/interim"):
        self.dataframes = dataframes
        self.destination_dir = destination_dir

    def extract_personas(self, person_element_pattern: Union[str, re.Pattern] = r"(^[A-Za-z]*_[\d]?_?)([A-Za-z]*_?[\w\d]*)"):

        person_element_pattern = re.compile(person_element_pattern)

        persona_entities_prefixes = [
            'baptized',
            'bride',
            'deceased',
            'father',
            'godfather',
            'godmother',
            'godparent',
            'groom',
            'husband',
            'mother',
            'wife',
            'witness'
        ]

        personas = []
        persona_counter = 1

        for df in self.dataframes:
            
            event_type = self._get_event_type(df)

            for index, row in df.iterrows():

                if row['event_type'] == event_type:
                    event_idno = f"{event_type.lower()}-{int(index) + 1}"
                    
                    personas_data = {}

                    for column_name in row.index:
                        match = re.search(person_element_pattern, column_name)
                        if match:

                            prefix = match.group(1)
                            attribute = match.group(2)

                            remove_pattern = re.compile(r"\d")
                            prefix = remove_pattern.sub("", prefix).strip("_")

                            if prefix in persona_entities_prefixes:
                                if prefix not in personas_data:
                                    personas_data[prefix] = {
                                        'event_idno': event_idno,
                                        'original_identifier': row['identifier'],
                                        'persona_type': prefix
                                    }

                                attribute_clean = attribute.strip("_")
                                personas_data[prefix][attribute_clean] = row[column_name]


                    if event_type and event_type.lower() == 'matrimonio':
                        personas_data = self._extract_embedded_parents(
                            personas_data,
                            event_idno,
                            row['identifier']
                        )


                    for persona in personas_data.values():
                        if pd.notna(persona.get('name')) or pd.notna(persona.get('lastname')):
                            persona['persona_idno'] = f"persona-{persona_counter}"
                            persona_counter += 1
    
                            personas.append(persona)

        personas_dataframe = pd.DataFrame.from_records(personas)

        # bulk inferences
        personas_dataframe['gender'] = GenderInferrer.GenderInferrer(personas_dataframe['name']).infer_from_names()
        
        normalizer = InferCondition.AttributeNormalizer(mapping_file="../data/mappings/conditionMapping.json")

        ## This code was generated by Claude Sonnet 4
        extraction_strategies = {
            'social_condition_harmonized': {
                'primary': 'social_condition',
                'secondary': ['legitimacy_status', 'marital_status']
            },
            'legitimacy_status_harmonized': {
                'primary': 'legitimacy_status', 
                'secondary': ['social_condition', 'marital_status']
            },
            'marital_status_harmonized': {
                'primary': 'marital_status',
                'secondary': ['social_condition', 'legitimacy_status']
            }
        }

        for target_attr, strategy in extraction_strategies.items():
            extractions = []
            
            if strategy['primary'] in personas_dataframe.columns:
                method = getattr(normalizer, f"extract_{target_attr.replace('_harmonized', '')}")
                extractions.append(method(personas_dataframe[strategy['primary']]))

            for col in strategy['secondary']:
                if col in personas_dataframe.columns:
                    method = getattr(normalizer, f"extract_{target_attr.replace('_harmonized', '')}")
                    extractions.append(method(personas_dataframe[col]))

            personas_dataframe[target_attr] = self.combine_extractions(extractions)

            ## End of code generated by Claude Sonnet 4

        # Remove noisy columns and replace them with the harmonized ones

        personas_dataframe['social_condition'] = personas_dataframe['social_condition_harmonized']
        personas_dataframe['legitimacy_status'] = personas_dataframe['legitimacy_status_harmonized']
        personas_dataframe['marital_status'] = personas_dataframe['marital_status_harmonized']

        personas_dataframe = personas_dataframe.drop(columns=['social_condition_harmonized', 'legitimacy_status_harmonized', 'marital_status_harmonized'], errors='ignore')

        # remove empty columns
        personas_dataframe = personas_dataframe.dropna(axis=1, how='all')

        return personas_dataframe


    def _get_event_type(self, df):
        # Logic to extract event type from the DataFrame
        return df['event_type'].iloc[0] if 'event_type' in df.columns else None

    def _extract_embedded_parents(self, personas_data, event_idno, original_identifier):

        for persona_type in ['groom', 'bride']:
            if persona_type in personas_data:
                persona = personas_data[persona_type]

                father_data = {}
                mother_data = {}

                for attr in list(persona.keys()):
                    if attr.startswith('father_'):
                        clean_attr = attr.replace('father_', '')
                        father_data[clean_attr] = persona.pop(attr)
                    elif attr.startswith('mother_'):
                        clean_attr = attr.replace('mother_', '')
                        mother_data[clean_attr] = persona.pop(attr)

                if any(pd.notna(value) for value in father_data.values()):
                    father_key = f"father_of_{persona_type}"
                    personas_data[father_key] = {
                        'event_idno': event_idno,
                        'original_identifier': original_identifier,
                        'persona_type': father_key,
                        **father_data
                    }

                if any(pd.notna(value) for value in mother_data.values()):
                    mother_key = f"mother_of_{persona_type}"
                    personas_data[mother_key] = {
                        'event_idno': event_idno,
                        'original_identifier': original_identifier,
                        'persona_type': mother_key,
                        **mother_data
                    }

        return personas_data

    def combine_extractions(self, extraction_list):
        """
        Note: This function was generated by Claude Sonnet 4

        Combines multiple extraction results by taking the first non-null value
        or using other priority logic.
        """
        if not extraction_list:
            return pd.Series()
        
        combined = extraction_list[0].copy()

        for extraction in extraction_list[1:]:
            combined = combined.fillna(extraction)
        
        return combined

if __name__ == "__main__":
    bautismos = pd.read_csv("data/clean/bautismos_clean.csv")
    matrimonios = pd.read_csv("data/clean/matrimonios_clean.csv")
    entierros = pd.read_csv("data/clean/entierros_clean.csv")

    extractor = PersonaExtractor([bautismos, matrimonios, entierros])
    personas = extractor.extract_personas()

    personas.to_csv("data/interim/personas_extracted.csv", index=False)